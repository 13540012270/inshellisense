import * as fsAsync from "fs/promises";
import * as fs from "fs";
import * as path from "path";
import * as process from "process";
import * as child_process from "child_process";

const main = async () => {
  const basePath = path.join(process.cwd(), ".fig");
  if (!fs.existsSync(basePath)) {
    await fsAsync.cp(path.join(process.cwd(), "fig", "src"), basePath, {
      recursive: true,
    });
  }

  const directoryItems = await fsAsync.readdir(basePath, {
    withFileTypes: true,
  });
  await Promise.all(
    [directoryItems[10]].map(async (directoryItem) => {
      if (!directoryItem.isFile()) {
        return;
      }

      const spec: Fig.Spec = (
        await import(path.join(basePath, directoryItem.name))
      ).default;

      if (typeof spec === "function") {
        return;
      }

      const filenameWithoutExtension = path.parse(directoryItem.name).name;
      const subcommand = spec as unknown as Fig.Subcommand;
      const generatedCode = generateGolang(
        subcommand,
        filenameWithoutExtension
      );
      await fsAsync.writeFile(
        path.join(
          process.cwd(),
          "..",
          "specs",
          `${filenameWithoutExtension}.go`
        ),
        generatedCode
      );
    })
  );

  const generatedFilesPath = path.join(process.cwd(), "..", "specs");
  child_process.exec(`gofmt -w ${generatedFilesPath}`);
};

const generateArgs = (args: Fig.SingleOrArray<Fig.Arg>): string => {
  return "";
};

const generateOptions = (options: Fig.Option[]): string => {
  return "";
};

const generateSubcommand = (subcommand: Fig.Subcommand): string => {
  const name = Array.isArray(subcommand.name)
    ? `Name: []string{${subcommand.name.map((n) => `"${n}"`).join(",")}},`
    : `Name: "${subcommand.name}",`;

  const description =
    subcommand.description != null
      ? `Description: "${subcommand.description}",`
      : "";

  const args = subcommand.args != null ? generateArgs(subcommand.args) : "";
  const options =
    subcommand.options != null ? generateOptions(subcommand.options) : "";

  return `model.Subcommand{
    ${name}
    ${description}
    ${args}
    ${options}
  }`.replaceAll(/\s/g, "");
};

const generateGolang = (
  subcommand: Fig.Subcommand,
  filenameWithoutExtension: string
) => {
  return `// Code generated by autocomplete/extract/extract.ts. DO NOT EDIT.

  package specs
  
  import (
    "github.com/cpendery/clac/autocomplete/model"
  )

  func init() {
    Specs["${filenameWithoutExtension}"] = ${generateSubcommand(subcommand)}
  }`;
};

main();
