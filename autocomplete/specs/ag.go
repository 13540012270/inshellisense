// Code generated by autocomplete/extract/extract.ts. DO NOT EDIT.

package specs

import (
	"github.com/cpendery/clac/autocomplete/model"
)

func init() {
	Specs["ag"] = model.Subcommand{
		Name:        []string{"ag"},
		Description: `Recursively search for PATTERN in PATH. Like grep or ack, but faster`,
		Args: []model.Arg{{
			Name:       "pattern",
			IsOptional: true,
		}, {
			Templates:  []model.Template{model.TemplateFilepaths},
			Name:       "path",
			IsOptional: true,
			IsVariadic: true,
		}},
		Options: []model.Option{{
			Name:        []string{"--ackmate"},
			Description: `Output results in a format parseable by AckMate https://github.com/protocool/AckMate`,
		}, {
			Name:        []string{"--affinity"},
			Description: `Set thread affinity (if platform supports it)`,
			ExclusiveOn: []string{"--noaffinity"},
		}, {
			Name:        []string{"--noaffinity"},
			Description: `Don't set thread affinity (if platform supports it)`,
			ExclusiveOn: []string{"--affinity"},
		}, {
			Name:        []string{"-a", "--all-types"},
			Description: `Search all files. This doesn't include hidden files, and doesn't respect any ignore files`,
		}, {
			Name:        []string{"-A", "--after"},
			Description: `Print lines after match`,
			Args: []model.Arg{{
				Name:        "LINES",
				Description: `The amount of lines`,
				IsOptional:  true,
			}},
		}, {
			Name:        []string{"-B", "--before"},
			Description: `Print lines before match`,
			Args: []model.Arg{{
				Name:        "LINES",
				Description: `The amount of lines`,
				IsOptional:  true,
			}},
		}, {
			Name:        []string{"--nobreak"},
			Description: `Print a newline between matches in different files. Enabled by default`,
		}, {
			Name:        []string{"-c", "--count"},
			Description: `Only  print the number of matches in each file. Note: This is the number of matches, not the number of matching lines. Pipe output to wc -l if you want the number of matching lines`,
		}, {
			Name:        []string{"--color"},
			Description: `Print color codes in results`,
			ExclusiveOn: []string{"--nocolor"},
		}, {
			Name:        []string{"--nocolor"},
			Description: `Don't print color codes in results`,
			ExclusiveOn: []string{"--color"},
		}, {
			Name:        []string{"--color-line-number"},
			Description: `Color codes for line numbers. Default is 1;33`,
		}, {
			Name:        []string{"--color-match"},
			Description: `Color codes for result match numbers. Default is 30;43`,
		}, {
			Name:        []string{"--color-path"},
			Description: `Color codes for path names. Default is 1;32`,
		}, {
			Name:        []string{"--column"},
			Description: `Print column numbers in results`,
		}, {
			Name:        []string{"-C", "--context"},
			Description: `Print lines before and after matches`,
			Args: []model.Arg{{
				Name:        "LINES",
				Description: `The amount of lines`,
				IsOptional:  true,
			}},
		}, {
			Name:        []string{"-D", "--debug"},
			Description: `Output ridiculous amounts of debugging info. Not useful unless you're actually debugging`,
		}, {
			Name:        []string{"--depth"},
			Description: `Search up to NUM directories deep, -1 for unlimited`,
			Args: []model.Arg{{
				Name:        "NUM",
				Description: `The depth in directories to search`,
				IsOptional:  true,
			}},
		}, {
			Name:        []string{"--filename"},
			Description: `Print file names`,
			ExclusiveOn: []string{"--nofilename"},
		}, {
			Name:        []string{"--nofilename"},
			Description: `Don't print file names`,
			ExclusiveOn: []string{"--filename"},
		}, {
			Name:        []string{"-f", "--follow"},
			Description: `Follow symlinks`,
			ExclusiveOn: []string{"--nofollow"},
		}, {
			Name:        []string{"--nofollow"},
			Description: `Don't follow symlinks`,
			ExclusiveOn: []string{"-f", "--follow"},
		}, {
			Name:        []string{"-F", "--fixed-strings"},
			Description: `Alias for --literal for compatibility with grep`,
		}, {
			Name:        []string{"--group"},
			Description: `Lumps multiple matches in the same file together, and presents them under a single occurrence of the filename`,
			ExclusiveOn: []string{"--nogroup"},
		}, {
			Name:        []string{"--nogroup"},
			Description: `Refrains from lumping matches in the same file together, and instead places the filename at the start of each match line`,
			ExclusiveOn: []string{"--group"},
		}, {
			Name:        []string{"-g"},
			Description: `Print filenames matching PATTERN`,
			Args: []model.Arg{{
				Name:        "PATTERN",
				Description: `The pattern to look for`,
			}},
		}, {
			Name:        []string{"-G", "--file-search-regex"},
			Description: `Only search files whose names match PATTERN`,
			Args: []model.Arg{{
				Name:        "PATTERN",
				Description: `The pattern to look for`,
			}},
		}, {
			Name:        []string{"-H", "--heading"},
			Description: `Print filenames above matching contents`,
			ExclusiveOn: []string{"--noheading"},
		}, {
			Name:        []string{"--noheading"},
			Description: `Don't print filenames above matching contents`,
			ExclusiveOn: []string{"-H", "--heading"},
		}, {
			Name:        []string{"--hidden"},
			Description: `Search hidden files. This option obeys ignored files`,
		}, {
			Name:        []string{"--ignore"},
			Description: `Ignore files/directories whose names match this pattern. Literal file and directory names are also allowed`,
			Args: []model.Arg{{
				Templates:   []model.Template{model.TemplateFilepaths, model.TemplateFolders},
				Name:        "PATTERN",
				Description: `The pattern to look for`,
			}},
		}, {
			Name:        []string{"--ignore-dir"},
			Description: `Alias for --ignore for compatibility with ack`,
			Args: []model.Arg{{
				Templates:   []model.Template{model.TemplateFilepaths, model.TemplateFolders},
				Name:        "NAME",
				Description: `The directory to ignore`,
			}},
		}, {
			Name:        []string{"-i", "--ignore-case"},
			Description: `Match case-insensitively`,
		}, {
			Name:        []string{"-l", "--files-with-matches"},
			Description: `Only print the names of files containing matches, not the matching lines. An empty query will print all files that would be searched`,
		}, {
			Name:        []string{"-L", "--files-without-matches"},
			Description: `Only print the names of files that don't contain matches`,
		}, {
			Name:        []string{"--list-file-types"},
			Description: `See FILE TYPES below`,
		}, {
			Name:        []string{"-m", "--max-count"},
			Description: `Skip the rest of a file after NUM matches. Default is 0, which never skips`,
			Args: []model.Arg{{
				Name:        "NUM",
				Description: `The number of matches to skip after`,
				IsOptional:  true,
			}},
		}, {
			Name:        []string{"--mmap"},
			Description: `Use of memory-mapped I/O. Defaults to true on platforms where mmap() is faster than read(). (All but macOS.)`,
			ExclusiveOn: []string{"--nommap"},
		}, {
			Name:        []string{"--nommap"},
			Description: `Don't use of memory-mapped I/O. Defaults to true on platforms where mmap() is faster than read(). (All but macOS.)`,
			ExclusiveOn: []string{"--mmap"},
		}, {
			Name:        []string{"--multiline"},
			Description: `Match regexes across newlines`,
			ExclusiveOn: []string{"--nomultiline"},
		}, {
			Name:        []string{"--nomultiline"},
			Description: `Don't match regexes across newlines`,
			ExclusiveOn: []string{"--multiline"},
		}, {
			Name:        []string{"-n", "--norecurse"},
			Description: `Don't recurse into directories`,
			ExclusiveOn: []string{"-r", "--recurse"},
		}, {
			Name:        []string{"--numbers"},
			Description: `Print line numbers`,
			ExclusiveOn: []string{"--nonumbers"},
		}, {
			Name:        []string{"--nonumbers"},
			Description: `Don't print line numbers`,
			ExclusiveOn: []string{"--numbers"},
		}, {
			Name:        []string{"-o", "--only-matching"},
			Description: `Print only the matching part of the lines`,
		}, {
			Name:        []string{"--one-device"},
			Description: `When  recursing  directories, don't scan dirs that reside on other storage devices. This lets you avoid scanning slow network mounts. This feature is not supported on all platforms`,
		}, {
			Name:        []string{"-p", "--path-to-ignore"},
			Description: `Provide a path to a specific .ignore file`,
			Args: []model.Arg{{
				Templates:   []model.Template{model.TemplateFilepaths},
				Name:        "STRING",
				Description: `The path to the ignore file`,
			}},
		}, {
			Name:        []string{"--pager"},
			Description: `Use a pager such as less. Use --nopager to override. This option is also ignored if output is piped to another program`,
			Args: []model.Arg{{
				Name:        "COMMAND",
				Description: `The pager`,
				Suggestions: []model.Suggestion{{Name: []string{`more`}}, {Name: []string{`less`}}, {Name: []string{`most`}}},
			}},
		}, {
			Name: []string{"--parallel"},
			Description: `Parse the input stream as a search term, not data to search. This is meant to be  used  with  tools  such  as  GNU  parallel.  For  example:  echo "foo
bar
baz" | parallel "ag {} ." will run 3 instances of ag, searching the current directory for "foo", "bar", and "baz"`,
		}, {
			Name:        []string{"--print-long-lines"},
			Description: `Print matches on very long lines (> 2k characters by default)`,
		}, {
			Name:        []string{"--passthrough", "--passthru"},
			Description: `When searching a stream, print all lines even if they don't match`,
		}, {
			Name:        []string{"-Q", "--literal"},
			Description: `Do not parse PATTERN as a regular expression. Try to match it literally`,
		}, {
			Name:        []string{"-r", "--recurse"},
			Description: `Recurse into directories when searching. Default is true`,
			ExclusiveOn: []string{"-n", "--norecurse"},
		}, {
			Name:        []string{"-s", "--case-sensitive"},
			Description: `Match case-sensitively`,
		}, {
			Name:        []string{"-S", "--smart-case"},
			Description: `Match case-sensitively if there are any uppercase letters in PATTERN, case-insensitively otherwise. Enabled by default`,
		}, {
			Name:        []string{"--search-binary"},
			Description: `Search binary files for matches`,
		}, {
			Name:        []string{"--silent"},
			Description: `Suppress all log messages, including errors`,
		}, {
			Name:        []string{"--stats"},
			Description: `Print stats (files scanned, time taken, etc)`,
		}, {
			Name:        []string{"--stats-only"},
			Description: `Print stats (files scanned, time taken, etc) and nothing else`,
		}, {
			Name:        []string{"-t", "--all-text"},
			Description: `Search all text files. This doesn't include hidden files`,
		}, {
			Name:        []string{"-u", "--unrestricted"},
			Description: `Search all files. This ignores .ignore, .gitignore, etc. It searches binary and hidden files as well`,
		}, {
			Name:        []string{"-U", "--skip-vcs-ignores"},
			Description: `Ignore VCS ignore files (.gitignore, .hgignore), but still use .ignore`,
		}, {
			Name:        []string{"-v", "--invert-match"},
			Description: `Match every line not containing the specified pattern`,
		}, {
			Name:        []string{"-V", "--version"},
			Description: `Print version info`,
		}, {
			Name:        []string{"--vimgrep"},
			Description: `Output results in the same form as Vim's :vimgrep /pattern/g Here is a ~/.vimrc configuration example: set grepprg=ag --vimgrep $* set grepformat=%f:%l:%c:%m Then use :grep to grep for something. Then use :copen, :cn, :cp, etc. to navigate through the matches`,
		}, {
			Name:        []string{"-w", "--word-regexp"},
			Description: `Only match whole words`,
		}, {
			Name:        []string{"--workers"},
			Description: `Use NUM worker threads. Default is the number of CPU cores, with a max of 8`,
			Args: []model.Arg{{
				Name:        "NUM",
				Description: `The NUM of worker threads`,
				IsOptional:  true,
			}},
		}, {
			Name:        []string{"-z", "--search-zip"},
			Description: `Search contents of compressed files. Currently, gz and xz are supported. This option requires that ag is built with lzma and zlib`,
		}, {
			Name: []string{"-0", "--null", "--print0"},
			Description: `Separate the filenames with \\0, rather than 
: this allows xargs -0 <command> to correctly process filenames containing spaces or newlines`,
		}},
	}
}
