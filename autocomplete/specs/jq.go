// Code generated by autocomplete/extract/extract.ts. DO NOT EDIT.

package specs

import (
	"github.com/cpendery/clac/autocomplete/model"
)

func init() {
	Specs["jq"] = model.Subcommand{
		Name:        []string{"jq"},
		Description: `Command-line JSON processor`,
		Args: []model.Arg{{
			Name:        "filter",
			Description: `Must be enclosed in single quotes`,
		}, {
			Templates:  []model.Template{model.TemplateFilepaths},
			Name:       "files",
			IsOptional: true,
			IsVariadic: true,
		}},
		Options: []model.Option{{
			Name:        []string{"--version"},
			Description: `Output the jq version and exit with zero`,
		}, {
			Name:        []string{"--seq"},
			Description: `Use the application/json-seq MIME type scheme for separating JSON texts in jq's input and output`,
		}, {
			Name:        []string{"--stream"},
			Description: `Parse the input in streaming fashion, outputting arrays of path and leaf values`,
		}, {
			Name:        []string{"--slurp", "-s"},
			Description: `Instead of running the filter for each JSON object in the input, read the entire input stream into a large array and run the filter just once`,
		}, {
			Name:        []string{"--raw-input", "-R"},
			Description: `Don't parse the input as JSON. Instead, each line of text is passed to the filter as a string`,
		}, {
			Name:        []string{"--null-input", "-n"},
			Description: `Don't read any input at all! Instead, the filter is run once using null as the input`,
		}, {
			Name:        []string{"--compact-output", "-c"},
			Description: `By default, jq pretty-prints JSON output. Using this option will result in more compact output by instead putting each JSON object on a single line`,
		}, {
			Name:        []string{"--tab"},
			Description: `Use a tab for each indentation level instead of two spaces`,
		}, {
			Name:        []string{"--indent"},
			Description: `Use the given number of spaces for indentation`,
			Args: []model.Arg{{
				Name:        "n",
				Description: `No more than 7`,
			}},
		}, {
			Name:        []string{"--color-output", "-C"},
			Description: `By default, jq outputs colored JSON if writing to a terminal. You can force it to produce color even if writing to a pipe or a file using -C`,
		}, {
			Name:        []string{"--monochrome-output", "-M"},
			Description: `Disable color`,
		}, {
			Name:        []string{"--ascii-output", "-a"},
			Description: `Jq usually outputs non-ASCII Unicode codepoints as UTF-8, even if the input specified them as escape sequences`,
		}, {
			Name:        []string{"--unbuffered"},
			Description: `Flush the output after each JSON object is printed`,
		}, {
			Name:        []string{"--sort-keys", "-S"},
			Description: `Output the fields of each object with the keys in sorted orde`,
		}, {
			Name:        []string{"--raw-output", "-r"},
			Description: `If the filter's result is a string then it will be written directly to standard output rather than being formatted as a JSON string with quotes`,
		}, {
			Name:        []string{"--join-output", "-j"},
			Description: `Like -r but jq won't print a newline after each output`,
		}, {
			Name:        []string{"-f", "--from-file"},
			Description: `Read filter from the file rather than from a command line`,
			Args: []model.Arg{{
				Templates: []model.Template{model.TemplateFilepaths},
				Name:      "filename",
			}},
		}, {
			Name:        []string{"-L"},
			Description: `Prepend directory to the search list for modules`,
			Args: []model.Arg{{
				Templates: []model.Template{model.TemplateFolders},
				Name:      "directory",
			}},
		}, {
			Name:        []string{"-e", "--exit-status"},
			Description: `Sets the exit status of jq to 0 if the last output values was neither false nor null, 1 if the last output value was either false or null, or 4 if no valid result was ever produced`,
		}, {
			Name:        []string{"--arg"},
			Description: `This option passes a value to the jq program as a predefined variable`,
			Args: []model.Arg{{
				Name: "name",
			}, {
				Name: "value",
			}},
		}, {
			Name:        []string{"--argjson"},
			Description: `This option passes a JSON-encoded value to the jq program as a predefined variable`,
			Args: []model.Arg{{
				Name: "name",
			}, {
				Name: "JSON-text",
			}},
		}, {
			Name:        []string{"--slurpfile"},
			Description: `This option reads all the JSON texts in the named file and binds an array of the parsed JSON values to the given global variable`,
			Args: []model.Arg{{
				Name: "variable name",
			}, {
				Templates: []model.Template{model.TemplateFilepaths},
				Name:      "filename",
			}},
		}, {
			Name:        []string{"--rawfile"},
			Description: `This option reads in the named file and binds its contents to the given global variable`,
			Args: []model.Arg{{
				Name: "variable name",
			}, {
				Templates: []model.Template{model.TemplateFilepaths},
				Name:      "filename",
			}},
		}, {
			Name:        []string{"--args"},
			Description: `Remaining arguments are positional string arguments. These are available to the jq program as $ARGS.positional[]`,
		}, {
			Name:        []string{"--jsonargs"},
			Description: `Remaining arguments are positional JSON text arguments. These are available to the jq program as $ARGS.positional[]`,
		}, {
			Name:        []string{"--run-tests"},
			Description: `Runs the tests in the given file or standard input. This must be the last option given and does not honor all preceding options`,
			Args: []model.Arg{{
				Templates:  []model.Template{model.TemplateFilepaths},
				Name:       "filename",
				IsOptional: true,
			}},
		}},
	}
}
